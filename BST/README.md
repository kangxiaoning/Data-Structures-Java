二分搜索树
=========

# 1. 二叉树

``` 
      28
     / \
    /   \
   /     \
 16      30
 /\      /\
13 22   29 42
```

- 和链表一样，动态数据结构
```java
class Node {
    E e;
    Node left;  // 左孩子
    Node right; // 右孩子
}
```
- 二叉树（多叉树）
- 二叉树具有唯一根节点
- 二叉树每个节点最多有两个孩子
- 二叉树每个节点最多有一个父亲
- 二叉树具有天然递归结构
    - 每个节点的左子树也是二叉树
    - 每个节点的右子树也是二叉树
- 二叉树不一定是“满”的
    - 一个节点也是二叉树
    - Null（空）也是二叉树
``` 
      28
     / \
    /   \
   /     \
 16      30
 /\      /
13 22   29
```

# 2. 二分搜索树

- 二分搜索树是二叉树
- 二分搜索树的每个节点的值
    - 大于其左子树的所有节点的值
    - 小于其右子树的所有节点的值
- 每一颗子树也是二分搜索树
- 存储的元素必须有可比较性

# 3. 二分搜索树添加元素

- 这里实现的二分搜索树不包含重复元素
    - 如果想包含重复元素，只需要定义
        - 左子树小于等于节点或者右子树大于等于节点
    - 注意：之前讲的数组和链表，可以有重复元素
- 二分搜索树添加元素的非递归写法和链表很像
- 这个课程在二分搜索树方面的实现关注递归实现
- 在二分搜索树方面，递归比非递归实现简单



**递归开销**

递归写法本身具有更高的开销，虽然在现代计算机这种开销表现的不是很明显，
但是在一些极端情况下还是能看出很大的区别的，尤其是对于二分搜索树来说，
在最坏的情况下，它有可能退化为一个链表，在这中情况下，使用递归很容易
造成系统栈溢出。

# 4. 二分搜索树遍历

## 4.1 什么是遍历操作

- 遍历操作就是把所有节点都访问一遍
- 访问的原因和业务相关
- 在线性结构下，遍历是极其简单的
- 在树结构下，也没那么难

## 4.2 二分搜索树的递归操作

- 对于遍历操作，两颗子树都要顾及


```
function traverse(node):
    if (node == null)
        return;
        
访问该节点
traverse(node.left)
traverse(node.right)
```

## 4.3 二分搜索树的前序遍历

先访问节点，再访问左右子树。

## 4.4 中序遍历

访问该节点放在遍历该节点左子树和右子树中间。

- 二分搜索树的中序遍历结果是顺序的


```
function traverse(node):
    if (node == null)
        return;
        
traverse(node.left)
访问该节点
traverse(node.right)
```

## 4.4 后序遍历

后序遍历的一个应用：

- 为二分搜索树释放内存

```
function traverse(node):
    if (node == null)
        return;
        
traverse(node.left)
traverse(node.right)
访问该节点
```

# 5. 二分搜索树的层序遍历

前序、中序、后序本质上都是深度优先的遍历。

层序遍历又叫广度优先遍历。

借助队列完成。

## 5.1 广度优先遍历的意义

- 更快的找到问题的解
- 常用于算法设计-最短路径
- 图中的深度优先遍历和广度优先遍历

# 6. 二分搜索树-删除节点

从最简单的，删除二分搜索树的最小值和最大值开始。

最小值 - 从根节点一直向下找left，直到没有。
最大值 - 从根节点一直向下找right，直到没有。
