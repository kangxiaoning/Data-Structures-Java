集合和映射
========

Set and Map

# 1. 集合(set)

- 每个元素只能存在一次
- 回忆上一小节实现的二分搜索树不能盛放重复元素
- 二分搜索树是实现集合非常好的底层数据结构
- 典型应用
    - 客户统计
    - 词汇量统计


# 2. 集合定义的接口 

```
Set<E>

void add(E)             // 不能添加重复元素
void remove(E)
boolean contains(E)
int getSize()
boolean isEmpty() 
```

对于Set，设计的是一个接口，所以可以采用不同的底层数据结构来实现。上
一节用二分搜索树来实现了Set,这一节使用LinkedList来实现，叫做LinkedListSet。
为什么要单拿出来LinkedList来实现Set呢？这是因为BST和LinkedList都
属于动态数据结构，数据都是存储在Node中，只不过两个Node的定义不同。因此基于
这两种数据结构为底层实现Set后，可以相应比较性能，通过比较希望看到BST
的优势所在。

# 3. 集合的时间复杂度分析

对于我们实现的二分搜索树，同样的数据可以创建出不同的二分搜索树，最
差的情况下退化成链表，高度等于节点个数，按 1 2 3 4 5 6 这种顺序
来创建二分搜索树的就可以创建出退化成链表的二分搜索树。

这也就是我们实现的二分搜索树的局限性，最差的情况退化成和链表一样
的O(n)的时间复杂度。也下因为如此，需要解决这个问题，解决方法就是
创建平衡二叉树。

对于我们的二分搜索树时间复杂度分析来说，最准确的说法是O(h)。

| **操作** | **LinkedListSet** | **BSTSet -> 平均** |
| :--- | :---: | :---: |
| 增 add | O(n) | O(h) -> O(log<sup>n</sup>)|
| 查 contains | O(n) | O(h) -> O(log<sup>n</sup>) |
| 删 remove | O(n) | O(h) -> O(log<sup>n</sup>) |

对LinkedListSet来说，添加只需要O(1)的时间复杂度，只需要在Linkedlist
头节点添加即可，但是在LinkedListSet中为了保证添加的元素不重复，首先
需要扫描整个LinkedList，也就是首先需要查一遍，这个查的过程是O(n)的
时间复杂度，使得LinkedListSet的add操作时间复杂度是O(n)。删来说
是同理的，要先找到待删的元素，时间复杂度也是O(n)。在之前的测试用例中，
如果整本书有n个单词，最坏的情况下每个单词都不同，整体来说时间复试是O(n^2)
这个级别。


BSTSet中，每次操作最终经历了h（树的高度）个节点。

那么h和n是什么关系呢？假设h层的二分搜索树，每一层都是满的，节点数为n，
计算如下。

## 3.1. 每一层的节点数

- 0层：1
- 1层：2
- 2层：4
- 3层：8
- 4层：16
- ...
- h-1层：2<sup>(h-1)</sup>  

## 3.2. h层，一共多少个节点？

n = 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + 2<sup>3</sup> +2<sup>4</sup> + ... + 2<sup>(h-1)</sup> 

利用等比数列求和公式得 n = 1 * (1 - 2<sup>n</sup>)/1-2 =  2<sup>h</sup> - 1

推出 h = log<sub>2</sub>(n+1)
      = O(log<sub>2</sub>n)
      = O(log<sup>n</sup>) // 渐进时间复杂度中底数忽略不计

# 4. log<sup>n</sup>和n的差距

nlog<sup>n</sup>和n<sup>2</sup>的时间复杂度与下面一致，相当于都乘以n。

| **n取值** | **log<sup>n</sup>** | **n** | **差距** |
| :--- | :---: | :---: | :---: |
| n = 16 | 4 | 16 | 相差4倍 |
| n = 1024 | 10 | 1024 | 相差100倍 |
| n = 100万 | 20 | 100万 | 相差5万倍 |

n = 100 万时，相当于 1024 * 1024，log<sup>n</sup>大概等于20。

